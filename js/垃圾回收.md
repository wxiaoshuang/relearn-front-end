# 详解js的垃圾回收

## 垃圾回收方式

**垃圾回收分为手动回收和自动回收**

比如C语言，就是手动回收策略，内存的分配和销毁都是用代码控制

C语言内置了mallco和free函数

当数据要使用堆内存空间的时候，使用mallco 函数分配内存，然后再使用；当不再需要这些数据的时候，手动调用 free 函数释放内存

如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁数据使用的空间，那么这种情况就被称为**内存泄漏**。

另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，**产生的垃圾数据是由垃圾回收器来释放的**，并不需要手动通过代码来释放。

首先需要明白，在javascript中，**原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的**

我们来看看是如何分别回收的

## 栈中的数据是如何回收的

JavaScript中的代码在执行的时候，会形成一个调用栈，每当调用一个函数，就会为这个函数创建执行上下文，并将函数的执行上下文压入栈，当函数执行完毕，从栈顶弹出

```javascript
1 function foo() {
2    var a = 1
3    var b = {heap: 2}
4    bar()
5 }
6 function bar(num) {
7  var c = "string"
8  var d = [1, 3, 4]
9 }
10 foo()

```

当代码执行到第8行的时候，调用栈和堆空间如下,  与此同时，还有一个**记录当前执行状态的指针（称为 ESP）**,ESP总是指向栈顶

![image-20200324233948145](G:\relearn front-end\js\images\image-20200324233948145.png)

当bar函数执行结束之后，ESP下移到foo的执行上下文，虽然bar依然保存在栈中，但是已经是无效内存了，下次再有函数入栈，直接覆盖掉

所以说，当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。

## 堆中的数据是如何回收的

当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，bar 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间

**要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了**。

接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。

 V8 中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。

新生代的容量比较小，而老生代支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。



新生代的空间分为两部分：from和to,